name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch: {}

permissions:
  contents: write

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.WASABI_ACCESS_KEY }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.WASABI_SECRET_KEY }}
  AWS_DEFAULT_REGION: us-central-1
  AWS_REGION: us-central-1
  AWS_S3_USE_PATH_STYLE: "true"
  AWS_ENDPOINT_URL: https://s3.us-central-1.wasabisys.com
  AWS_ENDPOINT_URL_S3: https://s3.us-central-1.wasabisys.com
  S3_BUCKET: 4gmxev0u4um

jobs:

# --- purge to be safe -----------------------------------------------------
  purge-bucket:
    runs-on: ubuntu-latest
    steps:

      # 1) Connect to Wasabi
      - name: Preflight S3 auth (Wasabi)
        run: |
          set -euo pipefail
          aws --version
          aws s3api head-bucket --bucket "$S3_BUCKET" \
            --endpoint-url "$AWS_ENDPOINT_URL_S3" \
            --region "$AWS_DEFAULT_REGION"

      # 2) Recursive Purge
      - name: Purge bucket (non-versioned nuke)
        run: |
          set -euo pipefail
          # Delete all objects in the bucket (no versioning -> one shot)
          aws s3 rm "s3://$S3_BUCKET" \
            --recursive \
            --endpoint-url "$AWS_ENDPOINT_URL_S3" \
            --region "$AWS_DEFAULT_REGION" \
            --only-show-errors || true

      # 3) Ensure it's empty
      - name: Verify empty
        run: |
          set -euo pipefail

          # Get at most one object and extract its Key (text). If bucket is empty, this prints "None".
          FIRST_KEY=$(aws s3api list-objects-v2 \
            --bucket "$S3_BUCKET" \
            --endpoint-url "$AWS_ENDPOINT_URL_S3" \
            --region "$AWS_DEFAULT_REGION" \
            --max-items 1 \
            --query 'Contents[0].Key' \
            --output text)

          if [ "${FIRST_KEY:-None}" != "None" ]; then
            echo "Bucket is NOT empty. Example key: $FIRST_KEY"
            # quick listing to help debug
            aws s3 ls "s3://$S3_BUCKET" \
              --endpoint-url "$AWS_ENDPOINT_URL_S3" \
              --region "$AWS_DEFAULT_REGION" || true
            exit 1
          fi

          echo "Bucket is empty."

  # --- macOS build & upload -----------------------------------------------------
  build-macos:
    needs: purge-bucket
    runs-on: macos-14
    steps:
      # 1) Checkout repo at the tagged commit
      - uses: actions/checkout@v4

      # 2) Install pnpm
      - uses: pnpm/action-setup@v4
        with: { version: 9 }

      # 3) Install Node 20 and enable pnpm cache
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: pnpm }

      # 4) Install deps (no lockfile strictness so CI can resolve if needed)
      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile

      # 5) Build shared/electron/vite bundles via package.json script
      - name: Build app
        run: pnpm build

      # 6) Package macOS: 
        # DMG (first install) + ZIP (auto-update payload) as universal binary
        # --publish never: upload manually awscli
      - name: Package (electron-builder)
        run: pnpm electron-builder --mac dmg zip --universal --publish never

      # 7) List produced files for easy debugging if something goes wrong
      - name: Show artifacts
        run: |
          set -euxo pipefail
          if [ -d release ]; then
            find release -maxdepth 2 -type f | sed 's/^/ - /'
          else
            echo "No release/ directory"; exit 1
          fi

      # 8) Sanity check: confirm the update manifest exists and points to Wasabi,
      #    and that the expected ZIP + blockmap are present before uploading.
      - name: Sanity check for the update manifest (macOS)
        run: |
          set -euo pipefail

          # 1) Manifest exists and references the zip we built
          test -f release/latest-mac.yml
          echo "----- latest-mac.yml -----"
          cat release/latest-mac.yml

          # Ensure manifest lists the auto-update payload(s)
          grep -qE 'files:\s*$' release/latest-mac.yml
          grep -q 'mac-universal.zip' release/latest-mac.yml

          # 2) Artifacts exist
          ZIP_PATH=$(ls release/*-mac-universal.zip)
          BLOCKMAP_PATH=$(ls release/*-mac-universal.zip.blockmap)
          echo "ZIP: $ZIP_PATH"
          echo "BLOCKMAP: $BLOCKMAP_PATH"

          # 3) Verify the embedded app-update.yml (this is what carries your Wasabi URL)
          TMPDIR="$(mktemp -d)"
          unzip -q "$ZIP_PATH" -d "$TMPDIR"
          APP_UPDATE=$(find "$TMPDIR" -name app-update.yml | head -n1)

          if [ -z "$APP_UPDATE" ]; then
            echo "app-update.yml not found inside the .app bundle extracted from ZIP"; exit 1
          fi

          echo "----- app-update.yml -----"
          cat "$APP_UPDATE"

          # Check provider + URL
          BASE_URL="${AWS_ENDPOINT_URL_S3%/}/${S3_BUCKET}"
          grep -q '^provider:.*generic' "$APP_UPDATE"
          grep -q "$BASE_URL" "$APP_UPDATE"

          echo "macOS manifest and embedded feed URL look good."

      # 9) Upload macOS binaries (for users to download manually and for completeness)
      #    Note: updater actually uses the ZIP + blockmap; DMG is for first install.
      - name: Upload macOS binaries (DMG/ZIP + blockmap)
        run: |
          set -euxo pipefail
          aws s3 cp "release/" "s3://$S3_BUCKET/" \
            --recursive \
            --endpoint-url "$AWS_ENDPOINT_URL_S3" \
            --region "$AWS_DEFAULT_REGION" \
            --acl public-read \
            --exclude "*" \
            --include "*-mac-universal.dmg" \
            --include "*-mac-universal.zip" \
            --include "*-mac-universal.zip.blockmap"

      # 10) Upload macOS update manifest (what electron-updater fetches first)
      - name: Upload macOS manifest (latest-mac.yml)
        run: |
          set -euxo pipefail
          aws s3 cp "release/latest-mac.yml" "s3://$S3_BUCKET/latest-mac.yml" \
            --endpoint-url "$AWS_ENDPOINT_URL_S3" \
            --region "$AWS_DEFAULT_REGION" \
            --acl public-read


# --- Windows build & upload ---------------------------------------------------
  build-windows:
    needs: purge-bucket
    runs-on: windows-latest
    steps:
      # 1) Checkout repo at the tagged commit
      - uses: actions/checkout@v4

      # 2) Install pnpm
      - uses: pnpm/action-setup@v4
        with: { version: 9 }

      # 3) Install Node 20 and enable pnpm cache
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: pnpm }

      # 4) Install deps
      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile
        shell: bash

      # 5) Build your shared/electron/vite bundles via your package.json scripts
      - name: Build app
        run: pnpm build
        shell: bash

      # 6) Package Windows: NSIS (EXE) + ZIP (ZIP not needed for updater but harmless)
      #    --publish never: we upload ourselves with awscli
      - name: Package (electron-builder)
        run: pnpm electron-builder --win nsis zip --x64 --publish never
        shell: bash

      # 7) List produced files for easy debugging
      - name: Show artifacts
        shell: pwsh
        run: |
          if (Test-Path release) {
            Get-ChildItem -Recurse -File release | Select-Object FullName, Length | Format-Table -AutoSize
          } else {
            Write-Error "No release/ directory"; exit 1
          }

      # 8) Sanity check: confirm the update manifest exists and points to Wasabi,
      #    and that the expected EXE + blockmap are present before uploading.
      - name: Sanity check for the update manifest (Windows)
        shell: pwsh
        run: |
          # 1) Manifest exists and mentions the EXE
          if (-not (Test-Path "release/latest.yml")) { throw "latest.yml missing" }
          "----- latest.yml -----"
          Get-Content "release/latest.yml"
          Select-String -Path "release/latest.yml" -Pattern '\.exe' | Out-Null

          # 2) Artifacts exist
          $exe = Get-ChildItem -Path release -Filter *.exe -Recurse | Select-Object -First 1
          $blk = Get-ChildItem -Path release -Filter *.exe.blockmap -Recurse | Select-Object -First 1
          if (-not $exe) { throw "No .exe found in release/" }
          if (-not $blk) { throw "No .exe.blockmap found in release/" }

          "Windows manifest references EXE and artifacts are present."

      # 9) Upload Windows binaries for updater (EXE + blockmap)
      - name: Upload Windows binaries (EXE + blockmap)
        shell: pwsh
        run: |
          aws s3 cp "release/" "s3://$Env:S3_BUCKET/" `
            --recursive `
            --endpoint-url "$Env:AWS_ENDPOINT_URL_S3" `
            --region "$Env:AWS_DEFAULT_REGION" `
            --acl public-read `
            --exclude "*" `
            --include "*.exe" `
            --include "*.exe.blockmap"

      # 10) Upload Windows update manifest (what electron-updater fetches first)
      - name: Upload Windows manifest (latest.yml)
        shell: pwsh
        run: |
          aws s3 cp "release/latest.yml" "s3://$Env:S3_BUCKET/latest.yml" `
            --endpoint-url "$Env:AWS_ENDPOINT_URL_S3" `
            --region "$Env:AWS_DEFAULT_REGION" `
            --acl public-read